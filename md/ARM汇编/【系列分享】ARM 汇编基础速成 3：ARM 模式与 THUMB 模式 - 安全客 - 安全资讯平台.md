> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.anquanke.com](https://www.anquanke.com/post/id/86401)

> 安全客 - 安全资讯平台

![](https://p0.ssl.qhimg.com/t018e7082f0e7ecd2dc.png)

译者：[arnow117](http://bobao.360.cn/member/contribute?uid=941579989)

预估稿费：190RMB

投稿方式：发送邮件至 linwei#360.cn，或登陆网页版在线投稿

传送门

[【系列分享】ARM 汇编基础速成 1：ARM 汇编以及汇编语言基础介绍](http://bobao.360.cn/learning/detail/4070.html)

[**【系列分享】ARM 汇编基础速成 2：ARM 汇编中的数据类型**](http://bobao.360.cn/learning/detail/4075.html)

ARM 处理器有两个主要的操作状态，ARM 模式以及 Thumb 模式 (Jazelle 模式先不考虑)。这些模式与特权模式并不冲突。SVC 模式既可以在 ARM 下调用也可以在 Thumb 下调用。只不过两种状态的主要不同是指令集的不同，ARM 模式的指令集宽度是 32 位而 Thumb 是 16 位宽度 (但也可以是 32 位)。知道何时以及如何使用 Thumb 模式对于 ARM 漏洞利用的开发尤其重要。当我们写 ARM 的 shellcode 时候，我们需要尽可能的少用 NULL 以及使用 16 位宽度的 Thumb 指令以精简代码。

不同版本 ARM，其调用约定不完全相同，而且支持的 Thumb 指令集也是不完全相同。在某些版本山，ARM 提出了扩展型 Thumb 指令集 (也叫 Thumbv2)，允许执行 32 位宽的 Thumb 指令以及之前版本不支持的条件执行。为了在 Thumb 模式下使用条件执行指令，Thumb 提出了 "IT" 分支指令。然而，这条指令在之后的版本又被更改移除了，说是为了让一些事情变得更加简单方便。我并不清楚各个版本的 ARM 架构所支持的具体的 ARM/Thumb 指令集，而且我也的确不想知道。我觉得你也应该不用深究这个问题。因为你只需要知道你设备上的关键 ARM 版本所支持的 Thumb 指令集就可以了。以及 ARM 信息中心可以帮你弄清楚你的 ARM 版本到底是多少。

就像之前说到的，Thumb 也有很多不同的版本。不过不同的名字仅仅是为了区分不同版本的 Thumb 指令集而已 (也就是对于处理器来说，这些指令永远都是 Thumb 指令)。

**Thumb-1(16 位宽指令集)：**在 ARMv6 以及更早期的版本上使用。

**Thumb-2(16 位 / 32 位宽指令集)：**在 Thumb-1 基础上扩展的更多的指令集 (在 ARMv6T2 以及 ARMv7 即很多 32 位 Android 手机所支持的架构上使用)

**Thumb-EE：**包括一些改变以及对于动态生成代码的补充 (即那些在设备上执行前或者运行时编译的代码)

**ARM 与 Thumb 的不同之处**

**对于条件执行指令（不是条件跳转指令）：**所有的 ARM 状态指令都支持条件执行。一些版本的 ARM 处理器上允许在 Thumb 模式下通过 IT 汇编指令进行条件执行。条件执行减少了要被执行的指令数量，以及用来做分支跳转的语句，所以具有更高的代码密度。

**ARM 模式与 Thumb 模式的 32 位指令：**Thumb 的 32 位汇编指令都有类似于 a.w 的扩展后缀。

桶型移位是另一种独特的 ARM 模式特性。它可以被用来减少指令数量。比如说，为了减少使用乘法所需的两条指令 (乘法操作需要先乘 2 然后再把结果用 MOV 存储到另一个寄存器中)，就可以使用在 MOV 中自带移位乘法操作的左移指令 (Mov R1, R0, LSL #1)。

在 ARM 模式与 Thumb 模式间切换的话，以下两个条件之一必须满足：

我们可以在使用分支跳转指令 BX(branch and exchange) 或者分支链接跳转指令 BLX(branch,link and exchange) 时，将目的寄存器的最低位置为 1。之后的代码执行就会在 Thumb 模式下进行。你也许会好奇这样做目标跳转地址不就有对齐问题了么，因为代码都是 2 字节或者 4 字节对齐的？但事实上这并不会造成问题，因为处理器会直接忽略最低比特位的标识。更多的细节我们会在第 6 篇中解释。

我们之前有说过，在 CPSR 当前程序状态寄存器中，T 标志位用来代表当前程序是不是在 Thumb 模式下运行的。

**ARM 指令集规律含义**

这一节的目的是简要的介绍 ARM 的通用指令集。知道每一句汇编指令是怎么操作使用，相互关联，最终组成程序是很重要的。之前说过，汇编语言是由构建机器码块的指令组成。所以 ARM 指令通常由助记符外加一到两个跟在后面的操作符组成，如下面的模板所示：

```
MNEMONIC{S}{condition} {Rd}, Operand1, Operand2
助记符{是否使用CPSR}{是否条件执行以及条件} {目的寄存器}, 操作符1, 操作符2
```

由于 ARM 指令的灵活性，不是全部的指令都满足这个模板，不过大部分都满足了。下面来说说模板中的含义:  

```
MNEMONIC     - 指令的助记符如ADD
{S}          - 可选的扩展位，如果指令后加了S，则需要依据计算结果更新CPSR寄存器中的条件跳转相关的FLAG
{condition}  - 如果机器码要被条件执行，那它需要满足的条件标示
{Rd}         - 存储结果的目的寄存器
Operand1     - 第一个操作数，寄存器或者是一个立即数
Operand2     - 第二个(可变的)操作数，可以是一个立即数或者寄存器或者有偏移量的寄存器
```

当助记符，S，目的寄存器以及第一个操作数都被声明的时候，条件执行以及第二操作数需要一些声明。因为条件执行是依赖于 CPSR 寄存器的值的，更精确的说是寄存器中的一些比特位。第二操作数是一个可变操作数，因为我们可以以各种形式来使用它，立即数，寄存器，或者有偏移量的寄存器。举例来说，第二操作数还有如下操作：

```
#123                    - 立即数
Rx                      - 寄存器比如R1
Rx, ASR n               - 对寄存器中的值进行算术右移n位后的值
Rx, LSL n               - 对寄存器中的值进行逻辑左移n位后的值
Rx, LSR n               - 对寄存器中的值进行逻辑右移n位后的值
Rx, ROR n               - 对寄存器中的值进行循环右移n位后的值
Rx, RRX                 - 对寄存器中的值进行带扩展的循环右移1位后的值
```

在知道了这个机器码模板后，然我们试着去理解这些指令：

```
ADD   R0, R1, R2         - 将第一操作数R1的内容与第二操作数R2的内容相加，将结果存储到R0中。
ADD   R0, R1, #2         - 将第一操作数R1的内容与第二操作数一个立即数相加，将结果存到R0中
MOVLE R0, #5             - 当满足条件LE(Less and Equal,小于等于0)将第二操作数立即数5移动到R0中,注意这条指令与MOVLE R0, R0, #5相同
MOV   R0, R1, LSL #1     - 将第二操作数R1寄存器中的值逻辑左移1位后存入R0
```

最后我们总结一下，满足这个模板的一些通用 ARM 指令集以及其含义:

![](https://p1.ssl.qhimg.com/t012c4f64db0e000b91.png)

传送门

[【系列分享】ARM 汇编基础速成 1：ARM 汇编以及汇编语言基础介绍](http://bobao.360.cn/learning/detail/4070.html)

**[【系列分享】ARM 汇编基础速成 2：ARM 汇编中的数据类型](http://bobao.360.cn/learning/detail/4075.html)**